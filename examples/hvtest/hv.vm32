.SEGMENT code
.privLvl 0
.GLOBAL startup
.GLOBAL hvSegmentViolation
.GLOBAL hvInvalidOpcode
.GLOBAL hvDivisionByZero
.GLOBAL hvTrapHandler
.GLOBAL hvTimerInterrupt

startup:
	MOV CR_CS, 0
	MOV CR_DS, 1
	MOV CR_ES, 1
	MOV CR_RS, 2
	MOV CR_SS, 3

	MOV CR_STACKPTR, endOfStack

	MOV CR_SEGTBL, segementationTable

	#PUSH bootStr
	#CALL printString

	MOV r0, vmTable
	ADD r0, 9
	MOV r0(5), vm1CodeStart			#Set Entry point for VM
	MOV r0(6), vm1StackEnd			#Set Stackpointer (optional - after bootup SP is undefined)
	MOV CR_VMTBL, vmTable			#After every modification, reload must be triggered
	VMRESUME 1						#Jump into VM 1

	#This should not happen as we are only handling traps from now on
end:
	HALT
	JMP end

hvSegmentViolation:
	PRINT 0x42
	HALT

hvInvalidOpcode:
	PRINT 0x43
	HALT

hvDivisionByZero:
	PRINT 0x44
	HALT

hvTrapHandler:
	#PUSH trapStr
	#CALL printString

	POP r30		#get VM ID

	#PUSH r30	#and print it
	#CALL printInteger

	#PUSH trapStr2
	#CALL printString

	POP r0		#get Trap Reason
	#PUSH r0
	#CALL printInteger

	#Jump into handler
	CALL r0(hvTrapJumpTable)

	#resume back into VM
	VMRESUME r30

	HALT

hvTimerInterrupt:
	PRINT 0x45
	HALT

##########################################

hvHandleSegmentViolation:
	PUSH segViolStr
	CALL printString
	HALT

hvHandleInvalidInstruction:
	PUSH invInstrStr
	CALL printString
	HALT

handleDivisionByZero:
	PUSH divByZeroStr
	CALL printString
	HALT

handleHvTrap:
	PUSH vmtrapStr
	CALL printString
	HALT

hvHandleSoftwareInt:
	PUSH softwareIntStr
	CALL printString
	HALT

hvHandlePrivilegeViolation:
	PUSH privViolationStr
	CALL printString
	HALT

hvHandleSpecialRegisterRead:
	PUSH specialRegisterReadStr
	CALL printString
	HALT

hvHandleSpecialRegisterWrite:
	PUSH specialRegisterWriteStr
	CALL printString
	HALT

hvHandleHalt:
	PUSH haltStr
	CALL printString
	HALT

hvHandleHardwareAccess:
	#PUSH hardwareAccessStr
	#CALL printString

	POP r0		#return pointer
	POP r1		#get character to print
	PUSH r0		#put return pointer back FIXME: basepointer!

	PRINT r1	#print it

	#modify return IP of VM to point to next instruction after the print #FIXME: make the IP point to next instruction
	MOV r0, vmTable
	ADD r0, 9
	ADD r0(5), 2

	RET

hvHandleVmresume:
	PUSH vmresumeStr
	CALL printString
	HALT

##########################################

#first element on stack is pointer to string
printString:
	POP r1	#HACK, basepointer?
	POP r0
	PUSH r1
nextChar:
	CMP r0(0), 0
	JZ end_reg
	PRINT r0(0)
	ADD r0, 1
	JMP nextChar
end_reg:
	RET

printInteger:
	POP r1	#HACK, basepointer?
	POP r0
	PUSH r1

	MOV r1, 28
	MOV r2, 0xF0000000
nextNibble:
	MOV r3, numDigits
	MOV r4, r0

	AND r4, r2	#mask nibble
	SHR r4, r1	#shift nibble right

	ADD r3, r4	#get and print char
	PRINT r3(0)

	SHR r2, 4	#move mask to next nibble
	SUB r1, 4	#adjust position

	CMP r1, 28	#End?
	JGE done
	JMP nextNibble
done:
	PRINT 0xa
	RET


codeEnd:

##########################################

.SEGMENT data
startOfData:

bootStr:
	.string "VM32 Hypervisor booting\n"
trapStr:
	.string "Got HV TRAP from VM "
trapStr2:
	.string "Reason is "

segViolStr:
	.string "Segmentation violation\n"
invInstrStr:
	.string "Invalid Instruction\n"
divByZeroStr:
	.string "Divion by zero\n"
vmtrapStr:
	.string "HV Trap in VM\n"
softwareIntStr:
	.string "Software Interrupt\n"
privViolationStr:
	.string "Privilege Violation\n"
specialRegisterReadStr:
	.string "Special Register Read\n"
specialRegisterWriteStr:
	.string "Special Register Write\n"
haltStr:
	.string "VM halted itself\n"
hardwareAccessStr:
	.string "VM attempted hardware access\n"
vmresumeStr:
	.string "VM attempted VMRESUME opcode\n"


numDigits:
	.string "0123456789ABCDEF"

hvTrapJumpTable:
	.word hvHandleSegmentViolation
	.word hvHandleInvalidInstruction
	.word handleDivisionByZero
	.word handleHvTrap
	.word hvHandleSoftwareInt
	.word hvHandlePrivilegeViolation
	.word hvHandleSpecialRegisterRead
	.word hvHandleSpecialRegisterWrite
	.word hvHandleHalt
	.word hvHandleHardwareAccess
	.word hvHandleVmresume


segementationTable:
#		Start				Limit			Type		PrivLvl
#HV
.word	InterruptVectors,	codeEnd,		0,			0			#Hypervisor CS
.word	startOfData,		endOfData,		1,			0			#Hypervisor DS
.word	startOfRegisters,	endOfRegisters,	2,			0			#Hypervisor RS
.word	startOfStack,		endOfStack,		3,			0			#Hypervisor SS

#VM1
.word	vm1CodeStart,		vm1CodeEnd,		0,			0			#VM1 CS
.word	vm1DataStart,		vm1DataEnd,		1,			0			#VM1 DS
.word	vm1RegsStart,		vm1RegsEnd,		2,			0			#VM1 RS
.word	vm1StackStart,		vm1StackEnd,	3,			0			#VM1 SS

#EOT
.word	0xFFFFFFFF,			0xFFFFFFFF,		0xFFFFFFFF,	0xFFFFFFFF	#END of Table


vmTable:
#		CS			DS			ES			SS			RS			IP			SP			Flags		privLvl
.word	0,			1,			1,			3,			2,			0,			0,			0,			0			#Hypervisor
.word	4,			5,			5,			7,			6,			0,			0,			0,			0			#VM1
.word	0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF	#EOT

endOfData:

##########################################

.SEGMENT registers
startOfRegisters:
.alloc 31
endOfRegisters:

##########################################

.SEGMENT stack
startOfStack:
.alloc 512
endOfStack:
